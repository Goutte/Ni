<?php
/**
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * @package    apostrophePlugin
 * @subpackage    model
 * @author     P'unk Avenue <apostrophe@punkave.com>
 */
class PluginaMediaItemTable extends Doctrine_Table
{

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getLuceneIndex()
  {
    return aZendSearch::getLuceneIndex($this);
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getLuceneIndexFile()
  {
    return aZendSearch::getLuceneIndexFile($this);
  }

  /**
   * DOCUMENT ME
   * @param mixed $luceneQuery
   * @return mixed
   */
  public function searchLucene($luceneQuery)
  {
    return aZendSearch::searchLucene($this, $luceneQuery);
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function rebuildLuceneIndex()
  {
    return aZendSearch::rebuildLuceneIndex($this);
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function optimizeLuceneIndex()
  {
    return aZendSearch::optimizeLuceneIndex($this);
  }

  /**
   * DOCUMENT ME
   * @param Doctrine_Query $q
   * @param mixed $luceneQuery
   * @return mixed
   */
  public function addSearchQuery(Doctrine_Query $q = null, $luceneQuery)
  {
    if ($q)
    {
      $q->addSelect($q->getRootAlias() . '.*');
    }
    return aZendSearch::addSearchQuery($this, $q, $luceneQuery);
  }

  /**
   * Returns the folder in the filesystem to which media items should be stored
   */
  static public function getDirectory()
  {
    return aFiles::getUploadFolder('media_items');
  }
  
  /**
   * Returns the URL where media repository contents are found
   */
  static public function getUrl($options = array())
  {
    $absolute = isset($options['absolute']) && $options['absolute'];
    $result = sfConfig::get('app_aMedia_static_url', sfConfig::get('app_a_static_url', '') . '/uploads/media_items');
    return $result;
  }

  /**
   * Returns items for all ids in $ids. If an item does not exist,
   * that item is not returned; this is not considered an error.
   * You can easily compare count($result) to count($ids).
   * @param mixed $ids
   * @return mixed
   */
  static public function retrieveByIds($ids)
  {
    if (!count($ids))
    {
      // WHERE freaks out over empty lists. We don't.
      return array();
    }
    if (count($ids) == 1)
    {
      if (!$ids[0])
      {
        // preg_split and its ilk return a one-element array
        // with an empty string in it when passed an empty string.
        // Tolerate this.
        return array();
      }
    }
    $q = Doctrine_Query::create()->
      select('m.*')->
      from('aMediaItem m')->
      whereIn("m.id", $ids);
    aDoctrine::orderByList($q, $ids);
    return $q->execute();
  }

  /**
   * Returns a query matching media items satisfying the specified parameters, all of which
   * are optional:
   * 
   * tag
   * search
   * type (video, image, etc)
   * user (a username, to determine access rights)
   * aspect-width and aspect-height (returns only images with the specified aspect ratio)
   * minimum-width
   * minimum-height
   * width
   * height
   * ids
   * downloadable
   * embeddable
   * 
   * Parameters are passed safely via wildcards so it should be OK to pass unsanitized
   * external API inputs to this method.
   * 
   * 'ids' is an array of item IDs. If it is present, only items with one of those IDs are
   * potentially returned.
   * 
   * If 'search' is present, results are returned in descending order by match quality.
   * Otherwise, if 'ids' is present, results are returned in that order. Otherwise,
   * results are returned newest first.
   * @param mixed $params
   * @return mixed
   */
  static public function getBrowseQuery($params)
  {
    $query = Doctrine_Query::create();
    // We can't use an alias because that is incompatible with getObjectTaggedWithQuery
    $query->from('aMediaItem');
    if (isset($params['ids']))
    {
      $query->select('aMediaItem.*, c.*');
      aDoctrine::orderByList($query, $params['ids']);
      $query->andWhereIn("aMediaItem.id", $params['ids']);
    }
    // New: at least one of the specified tags must be present. This is kind of a pain to check for because
    // tags can be specified as arrays or a comma separated string
    if (isset($params['allowed_tags']) && (strlen($params['allowed_tags']) || (is_array($params['allowed_tags']) && count($params['allowed_tags']))))
    {
      $query = TagTable::getObjectTaggedWithQuery(
        'aMediaItem', $params['allowed_tags'], $query, array('nb_common_tags' => 1));
    }
    elseif (isset($params['tag']))
    {
      $query = TagTable::getObjectTaggedWithQuery(
        'aMediaItem', $params['tag'], $query);
    }
    if (isset($params['type']))
    {
      // Supports metatypes like _downloadable
      $types = array();
      $typeInfos = aMediaTools::getTypeInfos($params['type']);
      foreach ($typeInfos as $name => $info)
      {
        $types[] = $name;
      }
      if (count($types))
      {
        $query->andWhereIn("aMediaItem.type", $types);
      }
      else
      {
        $query->andWhere("0 <> 0");
      }
    }
    if (isset($params['allowed_categories']))
    {
      if (!count($params['allowed_categories']))
      {
        $query->andWhere('0 <> 0');
      }
      else
      {
        $query->innerJoin('aMediaItem.Categories mc1 WITH mc1.id IN (' . implode(',', aArray::getIds($params['allowed_categories'])) . ')');
      }
    }
    if (isset($params['category']))
    {
      $query->innerJoin('aMediaItem.Categories mc2 WITH mc2.slug = ?', array($params['category']));
    }
    if (isset($params['search']))
    {
      $query = Doctrine::getTable('aMediaItem')->addSearchQuery($query, $params['search']);
    }
    elseif (isset($params['ids']))
    {
      // orderBy added by aDoctrine::orderByIds
    }
    else
    {
      // Reverse chrono order if we're not ordering them by search relevance
      $query->orderBy('aMediaItem.id desc');
    }
    if (!sfContext::getInstance()->getUser()->hasCredential(sfConfig::get('app_a_view_locked_sufficient_credentials', 'view_locked')))
    {
      $query->andWhere('aMediaItem.view_is_secure = false');
    }
    if (isset($params['aspect-width']) && isset($params['aspect-height']))
    {
      $query->andWhere('(aMediaItem.width * ? / ?) = aMediaItem.height', array($params['aspect-height'] + 0, $params['aspect-width'] + 0));
    }
    if (isset($params['minimum-width']))
    {
      $query->andWhere('aMediaItem.width >= ?', array($params['minimum-width'] + 0));
    }
    if (isset($params['minimum-height']))
    {
      $query->andWhere('aMediaItem.height >= ?', array($params['minimum-height'] + 0));
    }
    if (isset($params['width']))
    {
      $query->andWhere('aMediaItem.width = ?', array($params['width'] + 0));
    }
    if (isset($params['height']))
    {
      $query->andWhere('aMediaItem.height = ?', array($params['height'] + 0));
    }
    // No crops in the browser please
    $query->andWhere("aMediaItem.slug NOT LIKE '%.%'");
    $query->leftJoin("aMediaItem.Categories c");
    
    return $query;
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  static public function getAllTagNameForUserWithCount()
  {
    // Retrieves only tags relating to media items this user is allowed to see
    $q = NULL;
    if (!sfContext::getInstance()->getUser()->hasCredential(sfConfig::get('app_a_view_locked_sufficient_credentials', 'view_locked')))
    {
      $q = Doctrine_Query::create()->from('Tagging tg, tg.Tag t, aMediaItem m');
      // If you're not logged in, you shouldn't see tags relating to secured stuff
      // Always IS FALSE, never = FALSE
      $q->andWhere('m.id = tg.taggable_id AND ((m.view_is_secure IS NULL) OR (m.view_is_secure IS  FALSE))');
    }
    return TagTable::getAllTagNameWithCount($q, 
      array("model" => "aMediaItem"));
  }

  /**
   * Retrieves media items matching the supplied array of ids, in the same order as the ids
   * (a simple whereIn does not do this). We must use an explicit select when using
   * aDoctrine::orderByList.
   * @param mixed $ids
   * @return mixed
   */
  public function findByIdsInOrder($ids)
  {
    if (empty($ids))
    {
      // Doctrine doesn't generate any clause at all for WHERE IN if an array if false. This is a bug, but
      // it doesn't seem to be getting fixed at the Doctrine level
      return Doctrine::getTable('aMediaItem')->createQuery('m')->select('m.*')->where('1 = 0');
    }
    $q = Doctrine::getTable('aMediaItem')->createQuery('m')->select('m.*')->whereIn('m.id', $ids);
    // Don't forget to put them in order!
    return aDoctrine::orderByList($q, $ids)->execute();
  }

  /**
   * DOCUMENT ME
   * @return mixed
   */
  public function getCountByCategory()
  {
    $raw = Doctrine::getTable('aCategory')->createQuery('c')->innerJoin('c.aMediaItemToCategory mtc')->select('c.name, c.slug,  count(mtc.media_item_id) as num')->groupBy('mtc.category_id')->orderBy('c.name ASC')->execute(array(), Doctrine::HYDRATE_ARRAY);
    $results = array();
    foreach ($raw as $info)
    {
      $results[$info['id']] = array('name' => $info['name'], 'slug' => $info['slug'], 'count' => $info['num']);
    }
    return $results;
  }

  /**
   * Column in category table that determines whether these are allowed in the category
   * @return mixed
   */
  public function getCategoryColumn()
  {
    return 'media_items';
  }

  /**
   * Add the provided file to the media library, following the same practices as the 
   * media library's standard upload actions and forms. The file is copied to the library.
   * You do not need to keep the original if it is a temporary file.
   *
   * By default this method pays close attention to what the user is doing in the context of
   * the media library (selecting things of certain sizes and types, filtering by type, reusing
   * existing media) but this can all be overridden via options.
   *
   * Default behavior: if the user's session does not indicate they are in the midst of a selection
   * operation or applying a filter in the media library, any type of downloadable media 
   * permissible in the media library will pass validation and be accepted. If the user's 
   * session indicates they are in the midst of a selection or filter operation then only media satisfying 
   * the type requirements of that operation will be accepted. If a selection operation has
   * minimum size constraints only media meeting those minimum constraints will be accepted.
   * app_aMedia_reuse_duplicates is true and an existing media item has the same md5 hash, it
   * will be returned instead of a new object.
   *
   * The file's basename is used to create a reasonable title for the media item. 
   *
   * On success, returns an array as follows:
   *
   * array('status' => 'ok', 'item' => [the new aMediaItem object])
   *
   * On failure, returns an array as follows:
   * array('status' => 'failed', 'error' => [descriptive error message suitable for the user])
   *
   * Options provided to override standard behavior:
   *
   * If the 'type' option is specified, then only media of that major media library type (image,
   * video, audio (MP3), office...) will be accepted.
   * 
   * To explicitly accept all downloadable media even if the user is filtering
   * for a specific type, you can use the _downloadable type (note leading underscore).
   *
   * If the 'constraints' option is specified, then $options['constraints']['minimumWidth'] and
   * $options['constraints']['minimumHeight'] are respecteds, media not meeting these will
   * be rejected.
   *
   * If the 'noConstraints' option is explicitly set true, then there will be no minimum width and
   * height, regardless of any constraints that apply to the selection in progress.
   *
   * If the 'reuseDuplicates' option is specified, then it is consulted instead of
   * app_aMedia_reuse_duplicates to determine whether to return existing media files
   * with the same md5 hash.
   *
   *
   * @param string $filename
   * @param array $options
   * @return array
   */
  public function addFileAsMediaItem($filename, $options = array())
  {
    $reuseDuplicates = isset($options['reuseDuplicates']) ? $options['reuseDuplicates'] : sfConfig::get('app_aMedia_reuse_duplicates');
    $title = isset($options['title']) ? $options['title'] : null;
    $mimeTypes = aMediaTools::getOption('mime_types');
    // It comes back as a mapping of extensions to types, get the types
    $extensions = array_keys($mimeTypes);
    $mimeTypes = array_values($mimeTypes);
    
    $type = isset($options['type']) ? $options['type'] : false;
    // What we are selecting to add to a page
    if (!$type)
    {
      $type = aMediaTools::getType();
    }
    if (!$type)
    {
      // What we are filtering for 
      $type = aMediaTools::getSearchParameter('type');
    }
    if ($type)
    {
      // This supports composite types like _downloadable
      $infos = aMediaTools::getTypeInfos($type);
      $extensions = array();
      foreach ($infos as $info)
      {
        if ($info['embeddable'])
        {
          // This widget is actually supplying a thumbnail - allow gif, jpg and png
          $info['extensions'] = array('gif', 'jpg', 'png');
        }
        foreach ($info['extensions'] as $extension)
        {
          $extensions[] = $extension;
        }
      }
      $mimeTypes = array();
      $mimeTypesByExtension = aMediaTools::getOption('mime_types');
      foreach ($extensions as $extension)
      {
        // Careful, if we are filtering for a particular type then not everything
        // will be on the list
        if (isset($mimeTypesByExtension[$extension]))
        {
          $mimeTypes[] = $mimeTypesByExtension[$extension];
        }
      }
    }
    // Make the validator aware of the minimum dimensions for
    // the selection operation in progress unless overridden by options
    
    if (isset($options['constraints']))
    {
      $minimumWidth = $options['constraints']['minimumWidth'];
      $minimumHeight = $options['constraints']['minimumHeight'];
    }    
    elseif (isset($options['noConstraints']) && $options['noConstraints'])
    {
      $minimumWidth = null;
      $minimumHeight = null;
    }
    else
    {
      $minimumWidth = null;
      $minimumHeight = null;
      if (aMediaTools::isSelecting())
      {
        $minimumWidth = aMediaTools::getAttribute('minimum-width');
        $minimumHeight = aMediaTools::getAttribute('minimum-height');
      }
    }
    $options = array("mime_types" => $mimeTypes,
      'validated_file_class' => 'aValidatedFile',
      "required" => true);
    if ($minimumWidth)
    {
      $options['minimum-width'] = $minimumWidth;
    }
    if ($minimumHeight)
    {
      $options['minimum-height'] = $minimumHeight;
    }
    $vfp = new aValidatorFilePersistent($options,
      array("mime_types" => "The following file types are accepted: " . implode(', ', $extensions)));

    $pathinfo = pathinfo($filename);
    $guid = aGuid::generate();
    try
    {
      $vf = $vfp->clean(
       array(
         'newfile' => 
           array('tmp_name' => $filename, 'name' => $pathinfo['basename']), 
         'persistid' => $guid)); 
    } catch (Exception $e)
    {
      return array('status' => 'failed', 'error' => $e->getMessage());
    }

    $item = new aMediaItem();
    $item->title = is_null($title) ? aMediaTools::filenameToTitle($pathinfo['basename']) : $title;
    if (!strlen($item->title))
    {
      return array('status' => 'failed', 'error' => 'Filename does not have a basename');
    }
    // The preSaveImage / save / saveImage dance is necessary because
    // the sluggable behavior doesn't kick in until save and the image file
    // needs a slug based filename.
    if (!$item->preSaveFile($vf))
    {
      // this shouldn't happen, but just in case
      return array('status' => 'failed', 'error' => 'Pre-save operations failed');
    }
    if ($reuseDuplicates)
    {
      $existing = $this->findOneByMd5($item->md5);
      if ($existing)
      {
        return array('status' => 'ok', 'item' => $existing);
      }
    }
    $item->save();
    if (!$item->saveFile($vf))
    {
      $item->delete();
      return array('status' => 'failed', 'error' => 'Save operation failed (out of space?)');
    }
    return array('status' => 'ok', 'item' => $item);
  }

  public function findDuplicateWithSameOwner($md5)
  {
    if ($md5 !== false)
    {
      try
      {
        $user_id = sfContext::getInstance()->getUser()->getGuardUser()->getId();
      } catch (sfException $e)
      {
        $user_id = null;
      }
      return $this->createQuery('m')->where('m.md5 = ? AND m.owner_id <=> ?', array($md5, $user_id))->fetchOne();
    }
    return null;
  }

  /**
   * Returns file path to the original. If this is a crop,
   * the true original's path is returned. Accepts both 
   * aMediaItem objects and unhydrated arrays with the same info
   * @param array $info
   * @param string $format
   * @return string
   */
  public function getOriginalPath($info, $format = false)
  {
    if ($format === false)
    {
      $format = $info['format'];
    }
    $slug = $info['slug'];
    if (preg_match('/^([^\.]*)\.(.*)$/', $slug, $matches))
    {
      $slug = $matches[1];
    }
    $path = aMediaItemTable::getDirectory() . 
      DIRECTORY_SEPARATOR . $slug . ".original.$format";
    return $path;
  }
}
